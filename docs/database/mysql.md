# Mysql Actual Combat 45
## framwork
### flow
- [Architecture Image](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)
- 客户端 client
- 连接器 connector 管理链接,权限验证 空闲连接默认8小时,超过会断开连接,占用内存在断开连接后才释放
- 查询缓存 cache query 不推荐,因为update会重新构建缓存
- 分析器 词法分析,语法分析
- 优化器 索引选择,执行计划生成,查询顺序,表关联顺序分析
- 执行器 操作引擎, 返回结果
- 上面构成一个server
- 存储引擎 多个引擎公用一个server,存储数据,提供读写接口
## logs
### redo log
- 重要的回复日志
- 修改先记录在内存中,写入redo log,等系统不繁忙的时候再写入数据库
- 固定大小,写满需要擦除之前的再继续写
- write pos, checkpoint
- innerdb独有
### binlog
- mysql通用日志,server层实现
- redo log是物理日志,记录某页做了什么修改, binlog 是逻辑日志,记录语句原始逻辑
- binlog是追加写入,写满会切换到下一个文件
- 没有crash-safe能力
### update执行逻辑
- 查询语句,是否在内存中,不在读入内存
- 修改数据,写入内存
- 写入redo log,redo log状态prepare
- 写入binlog,
- 提交事务,修改redo log状态commit
- 两端提交时为了防止down机导致数据库数据不一致
## 事务
### 事务隔离
- 原子性
    - 任务是一个独立的操作单元,要么全部成功,要么全部失败
- 一致性
  - 事务开始和结束之间的中间状态不会被别的事务看到
- 隔离性
  - 适当的破坏一致性来提升性能和并行度,事务之间是互不可见的
- 持久性
  - 事务提交后保证不丢失
### 隔离级别
- 读未提交 一个事务还没提交时，它做的变更就能被别的事务看到
- 读提交 一个事务提交之后，它做的变更才会被其他事务看到
- 可重复读 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的
- 串行化 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成, 才能继续执行
- 实现方式,使用视图,可重复读在事务开始时创建视图,读提交在sql开始执行时创建视图,读未提交直接使用最新值,串行化使用加锁,也无需创建视图
### 回滚实现方式
- 每条数据提交前会生成一个回滚日志,同一条记录可存在多个版本回滚日志
- 在没有事务会用到数据时,回滚日志会删除
- 不建议使用长事务,因为会占用锁,以及会使回滚事务无法释放
- commit work and chain 多次交互可以使用该语法,结束上次事务同时开启下次事务
### 事务隔离
- 快照: innerdb为每个事务创建一个数组,记录事务启动时的活跃事务id,指启动了还未提交的事务
- 每个事务都有一个唯一ID transaction id
- 一行记录可能有多个事务版本
- 语句更新会生成undo log, 多个事务版本可依据undo log实现回滚
- 更新数据都是先读后写,读只能读到当前值,称为当前读
- 当前读总是读取已经提交的最新值
## 索引
### 数据类型
- HashTable 
  - 键值
  - 将key做hash计算数组位置
  - 将value放入数组中
  - hash冲突时,使用链表存储数据
  - 区间查询慢,适用于等值查询
- 有序数组
  - 范围查询,区间查询效率优秀
  - 更新效率低
  - 适用于存储不会改变的静态数据
- 二叉树
  - 访问磁盘次数过多导致查询时间久
  - 使用N叉树,降低访问磁盘次数和树层级
  - 在数据库索引中广泛使用
### innerDB
- 使用B+树
- 主键索引: 存储整行数据
- 非主键索引: 存储主键索引
- 非主键索引查询需要先查询主键在查询数据,遍历两次索引树,该过程称为回表
- 主键长度越小,普调索引叶子节点越小,普通索引存储空间越小
- 使用自增主键在性能和存储空间都有优势
- 在表只有一个索引时,可以考虑不使用自增主键
### 覆盖索引
- 定义: 需查询数据在索引树上,不需要回表.
- 如:使用非主键索引查询主键字段,或者联合索引字段
- 减少索引树的搜索次数,提升查询性能
### 最左前缀法则
- 可以匹配联合索引的最左N个字段,或者字符索引最左N个字符
- 联合索引顺序:
- 如调整顺序可以减少一个字段的索引维护,优先考虑
- 按照空间原则,占据空间大的在左边
### change buffer
- 在update操作时,如果数据页已在内存中就直接修改
- 如果数据页不在内存中,就将操作写入change buffer
- 在下次查询操作时,再将数据页读取到内存中处理,称为merge
- 除查询操作进行merge外,后台线程定期merge,数据库正常关闭也会出发merge
- 唯一索引不会触发change buffer,因为要判断唯一性,会将数据页读入内存
- change buffer 减少了磁盘读取,提高效率
- 应用于写多读少的表,如果读取频繁的表,change buffer不会起作用
### 索引自动选取
- 索引选取会依据扫描行数的预估,是否需要回表等来判断使用哪个索引
- 如果预估行数有误,可以使用analyze table tablename 来修正
## 锁
### 全局锁
- Flush tables with read lock
- 适用于全库逻辑备份
- 全库处于只读状态
- set global readonly = true 设置全局状态只读
- 使用ftwrl原因
  - 全局readonly有可能有其他逻辑
  - 异常处理机制不同,ftwrl出现异常会自动释放全局锁,而sgr会保持只读状态
## 表级锁
- 表锁: lock tables 不建议使用
- 元数据锁(MDL)
  - 保证读写正确性
  - 分为读锁和写锁
  - 读锁之间不互斥,读写锁,写锁之间互斥
  - MDL锁在语句执行前执行,在事务提交后释放
## 行锁
- 两阶段锁协议
  - 行锁在需要时加上,在事务提交后释放
- 将最有可能造成锁冲突,影响并发度的锁往后放
- record 锁, 单行索引加锁,锁加载索引上
- gap 锁, 锁加在索引记录之间的间隙上,并不包括索引本身,主要解决幻读问题
## 死锁
- 现象:cpu上升,mysql崩溃
- 处理方式: 超时等待(不推荐)
- 死锁检测: 回滚死锁事务链中的一个事务,让其他事务继续执行
  - 性能消耗提升,cpu资源消耗上升
  - 解决方式:控制并发量,对相同行的更新,在进入引擎前进行排队